<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seven Bridges of K√∂nigsberg</title>
    <link rel="icon" href="../favicon.ico">
    <style>
        :root {
            --bg-color: #222f3e;
            --water: #34ace0;
            --bridge-valid: #f1c40f; 
            --bridge-dull: #d35400;  
            --bridge-crossed: #7f8c8d;
            --text-color: #ecf0f1;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            user-select: none; /* Prevent highlighting text while playing */
        }

        h1 { margin-bottom: 5px; font-weight: 300; letter-spacing: 2px; text-transform: uppercase; }
        
        .status-bar {
            background: rgba(0,0,0,0.3);
            padding: 8px 20px;
            border-radius: 20px;
            margin-bottom: 20px;
            font-family: monospace;
            color: #48dbfb;
            font-size: 1.1rem;
            min-height: 24px;
            transition: color 0.2s;
        }
        .status-bar.error { color: #ff6b6b; animation: shake 0.3s; }

        .controls { display: flex; gap: 15px; margin-bottom: 20px; }

        button {
            padding: 10px 24px; border-radius: 25px; border: none;
            font-size: 1rem; font-weight: bold; cursor: pointer;
            background: #576574; color: white; transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }
        button.primary { background-color: #f1c40f; color: #2c3e50; }

        .game-container {
            position: relative;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid #576574;
        }

        canvas { display: block; }

        /* Overlay Messages */
        .message-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            opacity: 0; pointer-events: none; transition: opacity 0.3s;
            text-align: center; padding: 20px;
        }
        .message-overlay.active { opacity: 1; pointer-events: auto; }
        .message-text { font-size: 2.5rem; font-weight: bold; margin-bottom: 10px; color: #ff6b6b; }
        .message-sub { color: #bdc3c7; margin-bottom: 25px; font-size: 1.1rem; max-width: 400px; line-height: 1.5; }

        /* Modal */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex; align-items: center; justify-content: center;
            z-index: 1000; opacity: 0; pointer-events: none;
            transition: opacity 0.3s; backdrop-filter: blur(5px);
        }
        .modal-overlay.active { opacity: 1; pointer-events: auto; }
        .modal-card {
            background: white; padding: 30px; border-radius: 20px;
            max-width: 650px; width: 90%; color: #2d3436;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            transform: translateY(20px); transition: transform 0.3s;
            max-height: 85vh; overflow-y: auto;
        }
        .modal-overlay.active .modal-card { transform: translateY(0); }
        .modal-card h2 { margin-top: 0; color: #2c3e50; border-bottom: 2px solid #f0f0f0; padding-bottom: 15px; }
        .modal-card h3 { color: #2980b9; margin-top: 25px; margin-bottom: 10px; }
        .modal-card p, .modal-card li { line-height: 1.7; font-size: 1rem; color: #576574; }
        .highlight-box { background: #f1f2f6; border-left: 4px solid #e74c3c; padding: 15px; margin: 15px 0; border-radius: 4px; }
        .close-btn { margin-top: 25px; width: 100%; background: #2c3e50; color: white; padding: 12px; cursor: pointer; }

        .stats { margin-top: 10px; font-family: monospace; color: #bdc3c7; }
        
        @keyframes shake {
            0% { transform: translateX(0); } 25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); } 75% { transform: translateX(-5px); } 100% { transform: translateX(0); }
        }
    </style>
</head>
<body>

    <h1>The Seven Bridges</h1>
    
    <div class="status-bar" id="statusBar">Start: Tap a glowing bridge to move</div>

    <div class="controls">
        <button class="primary" onclick="resetGame()">Reset Map</button>
        <button onclick="toggleModal()">Give Up / Explain üí°</button>
    </div>

    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="message-overlay" id="msgOverlay">
            <div class="message-text">TRAPPED! üö´</div>
            <div class="message-sub">You are stuck in <span id="stuckLoc"></span>. Every path out has already been used.</div>
            <button class="primary" onclick="resetGame()">Try Again</button>
        </div>
    </div>

    <div class="stats">
        Bridges Crossed: <span id="score">0</span> / 7
    </div>

    <div class="modal-overlay" id="modal">
        <div class="modal-card">
            <h2>The Impossible Puzzle (1736)</h2>
            <p>You probably got stuck, right? <strong>That's because it's impossible.</strong></p>
            <p>In 1736, mathematician <strong>Leonhard Euler</strong> proved there is no solution to this map. This realization invented <em>Graph Theory</em>.</p>
            
            <h3>The Logic: "Enter and Leave"</h3>
            <p>Think of each landmass as a room. If you enter a room by one bridge, you must leave by another. This means bridges must come in pairs.</p>
            
            <div class="highlight-box">
                <strong>Euler's Rule:</strong> To cross every bridge exactly once, every landmass must have an <strong>EVEN</strong> number of bridges attached to it.<br><br>
                (The Start and End points are the only allowed exceptions).
            </div>

            <h3>Why You Failed (It's not your fault)</h3>
            <ul>
                <li>North Bank: 3 Bridges (Odd) ‚ùå</li>
                <li>South Bank: 3 Bridges (Odd) ‚ùå</li>
                <li>Middle Island: 5 Bridges (Odd) ‚ùå</li>
                <li>East Bank: 3 Bridges (Odd) ‚ùå</li>
            </ul>
            <p>Since all 4 spots have an ODD number of bridges, the math guarantees you will get stuck.</p>
            <button class="close-btn" onclick="toggleModal()">Close Explanation</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const statusBar = document.getElementById('statusBar');
        const msgOverlay = document.getElementById('msgOverlay');
        const stuckLoc = document.getElementById('stuckLoc');

        // Animation Vars
        let time = 0;
        let playerX = 300, playerY = 80; // Current rendered position
        let targetX = 300, targetY = 80; // Where we want to go

        // Game State
        let currentNode = 0; 
        let bridges = [];
        let crossedCount = 0;

        // Audio Context (Created on first interaction)
        let audioCtx;

        const nodes = {
            0: { x: 300, y: 80, label: "North" },
            1: { x: 300, y: 250, label: "Island" },
            2: { x: 300, y: 420, label: "South" },
            3: { x: 550, y: 250, label: "East" }
        };

        function init() {
            canvas.width = 600;
            canvas.height = 500;
            resetGame();
            
            // Mouse & Touch Listeners
            canvas.addEventListener('mousedown', (e) => handleInput(e.clientX, e.clientY));
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                handleInput(e.touches[0].clientX, e.touches[0].clientY);
            }, {passive: false});

            loop();
        }

        // --- SOUND GENERATOR (Web Audio API) ---
        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playSound(type) {
            if (!audioCtx) initAudio();
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            if (type === 'step') {
                // Happy "Bloop"
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'error') {
                // Low "Buzz"
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(100, now + 0.2);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
            } else if (type === 'fail') {
                // Sad "Wah wah"
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.linearRampToValueAtTime(100, now + 0.5);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.5);
                osc.start(now);
                osc.stop(now + 0.5);
            }
        }

        function resetGame() {
            msgOverlay.classList.remove('active');
            currentNode = 0; 
            targetX = nodes[0].x;
            targetY = nodes[0].y;
            // Teleport player immediately on reset
            playerX = targetX;
            playerY = targetY;
            
            crossedCount = 0;
            scoreEl.innerText = "0";
            updateStatus("Start: Tap a glowing bridge");
            
            bridges = [
                { from: 0, to: 1, x: 260, y: 165, w: 20, h: 80, crossed: false },
                { from: 0, to: 1, x: 340, y: 165, w: 20, h: 80, crossed: false },
                { from: 1, to: 2, x: 260, y: 335, w: 20, h: 80, crossed: false },
                { from: 1, to: 2, x: 340, y: 335, w: 20, h: 80, crossed: false },
                { from: 1, to: 3, x: 425, y: 250, w: 100, h: 20, crossed: false },
                { from: 0, to: 3, x: 450, y: 120, w: 20, h: 100, crossed: false, rotation: -0.5 },
                { from: 2, to: 3, x: 450, y: 380, w: 20, h: 100, crossed: false, rotation: 0.5 }
            ];
        }

        function updateStatus(msg, isError = false) {
            statusBar.innerText = msg;
            if (isError) {
                statusBar.classList.add('error');
                setTimeout(() => statusBar.classList.remove('error'), 400);
            }
        }

        function handleInput(clientX, clientY) {
            initAudio(); // Ensure audio context is ready
            const rect = canvas.getBoundingClientRect();
            const clickX = (clientX - rect.left) * (canvas.width / rect.width);
            const clickY = (clientY - rect.top) * (canvas.height / rect.height);

            let clickedValid = false;

            for (let b of bridges) {
                const dist = Math.sqrt((clickX - b.x) ** 2 + (clickY - b.y) ** 2);
                
                if (dist < 60) {
                    if (b.crossed) {
                        playSound('error');
                        updateStatus("Already crossed that one!", true);
                        return;
                    } 
                    if (b.from !== currentNode && b.to !== currentNode) {
                        playSound('error');
                        updateStatus("Too far! You can't fly.", true);
                        return;
                    }
                    
                    // Valid Move
                    crossBridge(b);
                    clickedValid = true;
                    return;
                }
            }
        }

        function crossBridge(b) {
            playSound('step');
            b.crossed = true;
            crossedCount++;
            scoreEl.innerText = crossedCount;
            
            // Set new Target for animation
            currentNode = (b.from === currentNode) ? b.to : b.from;
            targetX = nodes[currentNode].x;
            targetY = nodes[currentNode].y;

            updateStatus(`Moved to ${nodes[currentNode].label}. Keep going!`);
            checkGameState();
        }

        function checkGameState() {
            let canMove = false;
            for (let b of bridges) {
                if (!b.crossed && (b.from === currentNode || b.to === currentNode)) {
                    canMove = true;
                }
            }

            if (!canMove && crossedCount < 7) {
                stuckLoc.innerText = nodes[currentNode].label;
                setTimeout(() => { 
                    playSound('fail');
                    msgOverlay.classList.add('active'); 
                }, 800);
            }
        }

        function loop() {
            time += 0.05;
            
            // Smooth Player Animation (Linear Interpolation)
            playerX += (targetX - playerX) * 0.15;
            playerY += (targetY - playerY) * 0.15;

            draw();
            requestAnimationFrame(loop);
        }

        function draw() {
            // 1. Water with Waves
            ctx.fillStyle = "#34ace0";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = "rgba(255, 255, 255, 0.2)";
            ctx.lineWidth = 2;
            for(let i=0; i<10; i++) {
                let y = 50 * i + Math.sin(time + i) * 5;
                ctx.beginPath();
                ctx.moveTo(0, y);
                // Draw wave line
                for(let x=0; x<canvas.width; x+=20) {
                    ctx.lineTo(x, y + Math.sin(x/50 + time)*5);
                }
                ctx.stroke();
            }

            // 2. Land
            ctx.fillStyle = "#27ae60";
            ctx.beginPath(); ctx.rect(0, 0, 600, 130); ctx.fill(); // North
            ctx.beginPath(); ctx.rect(0, 370, 600, 130); ctx.fill(); // South
            ctx.beginPath(); ctx.ellipse(300, 250, 110, 60, 0, 0, Math.PI*2); ctx.fill(); // Island
            ctx.beginPath(); ctx.moveTo(600, 0); ctx.lineTo(480, 0); ctx.lineTo(550, 250); ctx.lineTo(480, 500); ctx.lineTo(600, 500); ctx.fill(); // East

            // 3. Bridges
            for (let b of bridges) {
                ctx.save();
                ctx.translate(b.x, b.y);
                if (b.rotation) ctx.rotate(b.rotation);
                
                const isConnected = (b.from === currentNode || b.to === currentNode);
                const isNearPlayer = (Math.abs(playerX - targetX) < 5 && Math.abs(playerY - targetY) < 5); // Only pulse when player stops moving

                if (b.crossed) {
                    ctx.fillStyle = "#7f8c8d";
                    ctx.shadowBlur = 0;
                } else if (isConnected && isNearPlayer) {
                    const glow = Math.abs(Math.sin(time * 2)) * 15 + 5;
                    ctx.shadowColor = "#f1c40f";
                    ctx.shadowBlur = glow;
                    ctx.fillStyle = "#f1c40f"; 
                } else {
                    ctx.fillStyle = "#d35400";
                    ctx.shadowBlur = 0;
                }

                ctx.strokeStyle = "#2c3e50";
                ctx.lineWidth = 2;
                ctx.fillRect(-b.w/2, -b.h/2, b.w, b.h);
                ctx.strokeRect(-b.w/2, -b.h/2, b.w, b.h);
                ctx.restore();
            }

            // 4. Player
            ctx.shadowBlur = 10; ctx.shadowColor = "rgba(0,0,0,0.5)";
            ctx.fillStyle = "white";
            ctx.beginPath(); ctx.arc(playerX, playerY, 15, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;
            
            // "YOU" Label
            ctx.fillStyle = "#2c3e50";
            ctx.font = "bold 10px sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("YOU", playerX, playerY);
        }

        function toggleModal() {
            document.getElementById('modal').classList.toggle('active');
        }

        init();
    </script>
</body>
</html>
