<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Markov Chain</title>
    <link rel="icon" href="../favicon.ico">
    <style>
        :root {
            --bg-grad-1: #1e3c72;
            --bg-grad-2: #2a5298;
            --card-bg: rgba(255, 255, 255, 0.1);
            --text-color: #ffffff;
            --accent-color: #00d2d3;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: linear-gradient(135deg, var(--bg-grad-1), var(--bg-grad-2));
            color: var(--text-color);
            margin: 0; padding: 20px;
            min-height: 100vh;
            display: flex; flex-direction: column; align-items: center;
        }

        h1 { margin: 10px 0 5px; font-weight: 300; letter-spacing: 3px; text-transform: uppercase; text-align: center; }
        .subtitle { font-size: 0.9rem; opacity: 0.7; margin-bottom: 20px; font-style: italic; text-align: center; }

        /* --- CONTROLS --- */
        .controls-top {
            background: rgba(0,0,0,0.3); padding: 10px 20px; border-radius: 50px;
            display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; align-items: center;
            margin-bottom: 20px; backdrop-filter: blur(10px);
        }

        select, button {
            background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.2);
            padding: 8px 15px; border-radius: 20px; cursor: pointer; font-size: 0.9rem;
            transition: all 0.2s;
        }
        select:focus, button:hover { background: rgba(255,255,255,0.2); outline: none; }
        .btn-action { background: var(--accent-color); color: #2c3e50; font-weight: bold; border: none; }
        .btn-action:active { transform: scale(0.95); }

        /* --- STAGE (The Graph) --- */
        .stage-container {
            position: relative; width: 100%; max-width: 500px; height: 400px;
            margin-bottom: 20px;
        }
        
        .svg-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 0;
        }
        
        /* Arrows */
        path {
            fill: none; stroke: rgba(255,255,255,0.1); stroke-width: 1;
            transition: stroke 0.2s;
        }
        path.active-path {
            stroke: var(--accent-color); stroke-width: 3;
            filter: drop-shadow(0 0 5px var(--accent-color));
        }

        /* Nodes */
        .node {
            position: absolute; width: 80px; height: 80px;
            border-radius: 50%; background: var(--card-bg);
            border: 2px solid rgba(255,255,255,0.3);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            backdrop-filter: blur(5px);
            transition: transform 0.2s, background-color 0.2s;
            z-index: 10;
            transform: translate(-50%, -50%); /* Center on coordinates */
        }
        .node.active {
            transform: translate(-50%, -50%) scale(1.2);
            border-color: #fff; background: rgba(255,255,255,0.2);
            box-shadow: 0 0 20px rgba(255,255,255,0.3);
            z-index: 20;
        }
        .node-icon { font-size: 2rem; }
        .node-label { font-size: 0.7rem; font-weight: bold; margin-top: 2px; text-transform: uppercase; }

        /* --- STATS --- */
        .stats-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px; width: 100%; max-width: 600px; margin-bottom: 20px;
        }
        .stat-card {
            background: rgba(0,0,0,0.2); padding: 10px; border-radius: 10px; text-align: center;
            border-bottom: 3px solid transparent;
        }
        .stat-val { font-size: 1.2rem; font-weight: bold; }
        .stat-name { font-size: 0.8rem; opacity: 0.7; }

        /* --- MODAL --- */
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: none; align-items: center; justify-content: center; z-index: 100;
        }
        .modal.open { display: flex; }
        .modal-content {
            background: #2c3e50; padding: 30px; border-radius: 20px; max-width: 500px; color: white;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5); position: relative;
        }
        textarea {
            width: 100%; height: 150px; background: rgba(0,0,0,0.3); color: lime; 
            border: 1px solid #555; padding: 10px; font-family: monospace; border-radius: 5px;
            margin: 10px 0;
        }
        
        .close-btn { position: absolute; top: 15px; right: 20px; font-size: 1.5rem; cursor: pointer; }
    </style>
</head>
<body>

    <h1>Markov Chain Sim</h1>
    <p class="subtitle">Visualizing state transitions over time</p>

    <div class="controls-top">
        <select id="presetSelect" onchange="loadPreset()">
            <option value="weather">2-State: Weather</option>
            <option value="life">3-State: Eat Sleep Code</option>
            <option value="gamble">2-State: Gambler</option>
            <option value="custom">Custom Matrix...</option>
        </select>
        
        <button onclick="toggleInfo()">‚ÑπÔ∏è Explain</button>
        <button onclick="toggleMute()" id="muteBtn">üîä</button>
    </div>

    <div class="stage-container" id="stage">
        <svg class="svg-layer" id="svgLayer">
            <defs>
                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="28" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="rgba(255,255,255,0.3)" />
                </marker>
            </defs>
            </svg>
        </div>

    <div class="stats-grid" id="statsGrid"></div>

    <div style="text-align:center; font-family: monospace; opacity: 0.6; margin-bottom: 20px;">
        Steps: <span id="stepCount">0</span>
    </div>

    <div class="controls-top">
        <button class="btn-action" onclick="manualStep()">+1 Step</button>
        <button class="btn-action" id="runBtn" onclick="toggleRun()">Run Fast</button>
        <div style="display:flex; flex-direction:column; align-items:center;">
            <span style="font-size:0.6rem;">SPEED</span>
            <input type="range" id="speedRange" min="1" max="100" value="10">
        </div>
        <button onclick="reset()">Reset</button>
    </div>

    <div class="modal" id="infoModal">
        <div class="modal-content">
            <span class="close-btn" onclick="toggleInfo()">&times;</span>
            <h2>What is a Markov Chain?</h2>
            <p>It's a mathematical system that hops from one "State" to another according to fixed probability rules.</p>
            <p><strong>The Golden Rule (Memoryless):</strong><br>
            The future depends <em>only</em> on where you are right now, not where you were before. The past doesn't matter!</p>
            <hr style="border:0; border-top:1px solid rgba(255,255,255,0.1); margin: 20px 0;">
            <p><strong>Try it:</strong><br>Select "Custom Matrix" to input your own probabilities and see what happens!</p>
        </div>
    </div>

    <div class="modal" id="customModal">
        <div class="modal-content">
            <span class="close-btn" onclick="document.getElementById('customModal').classList.remove('open')">&times;</span>
            <h2>Custom Matrix</h2>
            <p>Enter a Transition Matrix (rows must sum to 1). Format: JSON.</p>
            <textarea id="matrixInput" spellcheck="false">
[
  [0.5, 0.25, 0.25], 
  [0.25, 0.5, 0.25], 
  [0.25, 0.25, 0.5]
]</textarea>
            <div style="margin-bottom: 10px;">
                <label>Labels (comma separated):</label><br>
                <input type="text" id="labelsInput" value="A, B, C" style="width:100%; padding:8px; margin-top:5px; background:rgba(0,0,0,0.3); color:white; border:1px solid #555;">
            </div>
            <button class="btn-action" onclick="applyCustom()">Load Matrix</button>
            <p id="errorMsg" style="color: #ff7675; font-size: 0.8rem; margin-top: 10px;"></p>
        </div>
    </div>

    <script>
        // --- DATA ---
        const presets = {
            weather: {
                labels: ["Sunny", "Rainy"],
                icons: ["‚òÄÔ∏è", "üåßÔ∏è"],
                matrix: [[0.7, 0.3], [0.4, 0.6]],
                colors: ["#f1c40f", "#3498db"]
            },
            life: {
                labels: ["Eat", "Sleep", "Code"],
                icons: ["üçî", "üí§", "üíª"],
                matrix: [
                    [0.2, 0.1, 0.7], // Eat -> mostly Code
                    [0.1, 0.5, 0.4], // Sleep -> mostly Sleep or Code
                    [0.3, 0.3, 0.4]  // Code -> balanced
                ],
                colors: ["#e67e22", "#9b59b6", "#2ecc71"]
            },
            gamble: {
                labels: ["Win", "Loss"],
                icons: ["ü§ë", "üí∏"],
                matrix: [[0.45, 0.55], [0.45, 0.55]], // House edge
                colors: ["#2ecc71", "#e74c3c"]
            }
        };

        // --- STATE ---
        let currentConfig = null;
        let currentState = 0;
        let counts = [];
        let totalSteps = 0;
        let isRunning = false;
        let animFrame;
        
        // --- AUDIO ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        let isMuted = false;

        function playSound(stateIndex) {
            if (isMuted || audioCtx.state === 'suspended') return;
            const speed = parseInt(document.getElementById('speedRange').value);
            if(speed > 30) return; // Mute if too fast

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            // Pentatonic mapping based on state index
            const baseFreq = 220;
            const mult = [1, 1.12, 1.25, 1.5, 1.66]; // Scale ratios
            const freq = baseFreq * (mult[stateIndex % 5] || 2);

            osc.type = 'sine';
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);

            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        }

        // --- INIT & GRAPHICS ---
        function loadPreset() {
            const val = document.getElementById('presetSelect').value;
            if(val === 'custom') {
                document.getElementById('customModal').classList.add('open');
                return;
            }
            setup(presets[val]);
        }

        function applyCustom() {
            const txt = document.getElementById('matrixInput').value;
            const lbls = document.getElementById('labelsInput').value.split(',').map(s=>s.trim());
            
            try {
                const mat = JSON.parse(txt);
                // Basic validation
                if(!Array.isArray(mat) || mat.length !== mat[0].length) throw new Error("Matrix must be square array");
                
                // Build Config object
                const cfg = {
                    labels: lbls.slice(0, mat.length),
                    icons: mat.map((_,i) => String.fromCharCode(65+i)), // A, B, C icons
                    matrix: mat,
                    colors: mat.map((_,i) => `hsl(${i * (360/mat.length)}, 70%, 50%)`)
                };
                
                document.getElementById('customModal').classList.remove('open');
                setup(cfg);
            } catch(e) {
                document.getElementById('errorMsg').innerText = "Error: " + e.message;
            }
        }

        function setup(config) {
            currentConfig = config;
            currentState = 0;
            totalSteps = 0;
            counts = new Array(config.matrix.length).fill(0);
            
            renderGraph();
            renderStats();
            updateStatsUI();
        }

        function renderGraph() {
            const stage = document.getElementById('stage');
            const svg = document.getElementById('svgLayer');
            const num = currentConfig.matrix.length;
            
            // Clear old
            document.querySelectorAll('.node').forEach(e => e.remove());
            svg.innerHTML = '<defs><marker id="arrowhead" markerWidth="10" markerHeight="7" refX="28" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="rgba(255,255,255,0.3)" /></marker></defs>';

            const cx = stage.clientWidth / 2;
            const cy = stage.clientHeight / 2;
            const r = Math.min(cx, cy) - 60; // Radius

            // 1. Create Nodes
            for(let i=0; i<num; i++) {
                const angle = (i / num) * 2 * Math.PI - (Math.PI/2); // Start top
                const x = cx + r * Math.cos(angle);
                const y = cy + r * Math.sin(angle);

                const node = document.createElement('div');
                node.className = 'node';
                node.id = `node-${i}`;
                node.style.left = x + 'px';
                node.style.top = y + 'px';
                node.style.borderColor = currentConfig.colors[i];
                node.innerHTML = `
                    <div class="node-icon">${currentConfig.icons[i] || '#'}</div>
                    <div class="node-label">${currentConfig.labels[i]}</div>
                `;
                stage.appendChild(node);
            }

            // 2. Create Paths (Full Mesh)
            for(let i=0; i<num; i++) {
                for(let j=0; j<num; j++) {
                    if(currentConfig.matrix[i][j] > 0) {
                        createPath(i, j, num, cx, cy, r);
                    }
                }
            }
            
            highlightNode(0);
        }

        function createPath(from, to, total, cx, cy, r) {
            const svg = document.getElementById('svgLayer');
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.id = `path-${from}-${to}`;
            path.setAttribute("marker-end", "url(#arrowhead)");

            // Coords
            const ang1 = (from / total) * 2 * Math.PI - (Math.PI/2);
            const ang2 = (to / total) * 2 * Math.PI - (Math.PI/2);
            
            const x1 = cx + r * Math.cos(ang1);
            const y1 = cy + r * Math.sin(ang1);
            const x2 = cx + r * Math.cos(ang2);
            const y2 = cy + r * Math.sin(ang2);

            let d = "";
            if(from === to) {
                // Self Loop (Curve out and back)
                const loopR = 40;
                const lx = x1 + loopR * Math.cos(ang1);
                const ly = y1 + loopR * Math.sin(ang1);
                d = `M ${x1} ${y1} Q ${lx} ${ly} ${x1+5} ${y1+5}`; // Simplified loop
                // Actually self-loops in SVG are tricky without bezier control points pointing out
                // Let's just point it outwards
                const cx1 = x1 + 60 * Math.cos(ang1 - 0.3);
                const cy1 = y1 + 60 * Math.sin(ang1 - 0.3);
                const cx2 = x1 + 60 * Math.cos(ang1 + 0.3);
                const cy2 = y1 + 60 * Math.sin(ang1 + 0.3);
                d = `M ${x1} ${y1} C ${cx1} ${cy1}, ${cx2} ${cy2}, ${x1} ${y1}`;
            } else {
                // Curve towards center slightly to avoid overlapping straight lines
                // or curve outwards? Let's do simple straight for now, quadratic for style
                d = `M ${x1} ${y1} L ${x2} ${y2}`;
            }
            
            path.setAttribute("d", d);
            svg.appendChild(path);
        }

        function renderStats() {
            const grid = document.getElementById('statsGrid');
            grid.innerHTML = '';
            currentConfig.labels.forEach((lbl, i) => {
                const div = document.createElement('div');
                div.className = 'stat-card';
                div.style.borderBottomColor = currentConfig.colors[i];
                div.innerHTML = `
                    <div class="stat-name">${lbl}</div>
                    <div class="stat-val" id="val-${i}">0%</div>
                `;
                grid.appendChild(div);
            });
        }

        // --- LOGIC ---
        function step() {
            // 1. Get Row
            const row = currentConfig.matrix[currentState];
            
            // 2. Weighted Random
            const r = Math.random();
            let sum = 0;
            let nextState = -1;
            
            for(let i=0; i<row.length; i++) {
                sum += row[i];
                if(r < sum) {
                    nextState = i;
                    break;
                }
            }
            if(nextState === -1) nextState = row.length - 1; // Fallback

            // 3. Visuals
            highlightTransition(currentState, nextState);
            currentState = nextState;
            
            // 4. Data
            totalSteps++;
            counts[currentState]++;
            
            // 5. UI Updates
            updateStatsUI();
            playSound(currentState);
            highlightNode(currentState);
        }

        function highlightTransition(from, to) {
            const p = document.getElementById(`path-${from}-${to}`);
            if(p) {
                p.classList.add('active-path');
                setTimeout(()=>p.classList.remove('active-path'), 200);
            }
        }

        function highlightNode(idx) {
            document.querySelectorAll('.node').forEach(n => n.classList.remove('active'));
            document.getElementById(`node-${idx}`).classList.add('active');
        }

        function updateStatsUI() {
            document.getElementById('stepCount').innerText = totalSteps;
            counts.forEach((c, i) => {
                const pct = totalSteps === 0 ? 0 : ((c/totalSteps)*100).toFixed(1);
                document.getElementById(`val-${i}`).innerText = pct + "%";
            });
        }

        // --- CONTROLS ---
        function toggleRun() {
            isRunning = !isRunning;
            const btn = document.getElementById('runBtn');
            if(isRunning) {
                btn.innerText = "Pause";
                btn.classList.add('btn-action');
                if(audioCtx.state === 'suspended') audioCtx.resume();
                loop();
            } else {
                btn.innerText = "Run Fast";
                cancelAnimationFrame(animFrame);
            }
        }

        function loop() {
            if(!isRunning) return;
            
            const speed = parseInt(document.getElementById('speedRange').value);
            // Steps per frame logic
            let steps = 1;
            if(speed > 50) steps = Math.floor(Math.pow(speed-40, 1.5));
            
            for(let i=0; i<steps; i++) step();

            let delay = 0;
            if(speed < 40) delay = (40-speed) * 10;
            
            if(delay > 0) setTimeout(()=> animFrame = requestAnimationFrame(loop), delay);
            else animFrame = requestAnimationFrame(loop);
        }

        function manualStep() {
            if(isRunning) toggleRun();
            if(audioCtx.state === 'suspended') audioCtx.resume();
            step();
        }

        function reset() {
            isRunning = false;
            cancelAnimationFrame(animFrame);
            document.getElementById('runBtn').innerText = "Run Fast";
            setup(currentConfig);
        }

        function toggleInfo() { document.getElementById('infoModal').classList.toggle('open'); }
        function toggleMute() { 
            isMuted = !isMuted;
            document.getElementById('muteBtn').innerText = isMuted ? 'üîá' : 'üîä';
        }

        // Init
        window.onload = () => loadPreset();

    </script>
</body>
</html>
